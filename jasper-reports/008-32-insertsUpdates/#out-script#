formStr = 'the value for formStr'
I_formInt = 32
STR_CCC = 'ccc'
import time as _time
import math as _math
import sys as _sys

if _sys.platform.startswith('java'):
    from java.lang import Object
    from java.sql import Date, Timestamp, Time
    from java.util import Calendar
    from org.python.core import Py


MINYEAR = 1
MAXYEAR = 9999

_DAYS_IN_MONTH = [None, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]

_DAYS_BEFORE_MONTH = [None]
dbm = 0
for dim in _DAYS_IN_MONTH[1:]:
    _DAYS_BEFORE_MONTH.append(dbm)
    dbm += dim
del dbm, dim

def _is_leap(year):
    return year % 4 == 0 and (year % 100 != 0 or year % 400 == 0)

def _days_in_year(year):
    return 365 + _is_leap(year)

def _days_before_year(year):
    y = year - 1
    return y*365 + y//4 - y//100 + y//400

def _days_in_month(year, month):
    assert 1 <= month <= 12, month
    if month == 2 and _is_leap(year):
        return 29
    return _DAYS_IN_MONTH[month]

def _days_before_month(year, month):
    if not 1 <= month <= 12:
        raise ValueError('month must be in 1..12', month)
    return _DAYS_BEFORE_MONTH[month] + (month > 2 and _is_leap(year))

def _ymd2ord(year, month, day):
    if not 1 <= month <= 12:
        raise ValueError('month must be in 1..12', month)
    dim = _days_in_month(year, month)
    if not 1 <= day <= dim:
        raise ValueError('day must be in 1..%d' % dim, day)
    return (_days_before_year(year) +
            _days_before_month(year, month) +
            day)

_DI400Y = _days_before_year(401)    # number of days in 400 years
_DI100Y = _days_before_year(101)    #    "    "   "   " 100   "
_DI4Y   = _days_before_year(5)      #    "    "   "   "   4   "

assert _DI4Y == 4 * 365 + 1

assert _DI400Y == 4 * _DI100Y + 1

assert _DI100Y == 25 * _DI4Y - 1

def _ord2ymd(n):
    "ordinal -> (year, month, day), considering 01-Jan-0001 as day 1."


    n -= 1
    n400, n = divmod(n, _DI400Y)
    year = n400 * 400 + 1   # ..., -399, 1, 401, ...

    n100, n = divmod(n, _DI100Y)

    n4, n = divmod(n, _DI4Y)

    n1, n = divmod(n, 365)

    year += n100 * 100 + n4 * 4 + n1
    if n1 == 4 or n100 == 4:
        assert n == 0
        return year-1, 12, 31

    leapyear = n1 == 3 and (n4 != 24 or n100 == 3)
    assert leapyear == _is_leap(year)
    month = (n + 50) >> 5
    preceding = _DAYS_BEFORE_MONTH[month] + (month > 2 and leapyear)
    if preceding > n:  # estimate is too large
        month -= 1
        preceding -= _DAYS_IN_MONTH[month] + (month == 2 and leapyear)
    n -= preceding
    assert 0 <= n < _days_in_month(year, month)

    return year, month, n+1

_MONTHNAMES = [None, "Jan", "Feb", "Mar", "Apr", "May", "Jun",
                     "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
_DAYNAMES = [None, "Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"]


def _build_struct_time(y, m, d, hh, mm, ss, dstflag):
    wday = (_ymd2ord(y, m, d) + 6) % 7
    dnum = _days_before_month(y, m) + d
    return _time.struct_time((y, m, d, hh, mm, ss, wday, dnum, dstflag))

def _format_time(hh, mm, ss, us):
    # Skip trailing microseconds when us==0.
    result = "%02d:%02d:%02d" % (hh, mm, ss)
    if us:
        result += ".%06d" % us
    return result

def _wrap_strftime(object, format, timetuple):
    year = timetuple[0]
    if year < 1900:
        raise ValueError("year=%d is before 1900; the datetime strftime() "
                         "methods require year >= 1900" % year)
    zreplace = None # the string to use for %z
    Zreplace = None # the string to use for %Z

    newformat = []
    push = newformat.append
    i, n = 0, len(format)
    while i < n:
        ch = format[i]
        i += 1
        if ch == '%':
            if i < n:
                ch = format[i]
                i += 1
                if ch == 'z':
                    if zreplace is None:
                        zreplace = ""
                        if hasattr(object, "_utcoffset"):
                            offset = object._utcoffset()
                            if offset is not None:
                                sign = '+'
                                if offset < 0:
                                    offset = -offset
                                    sign = '-'
                                h, m = divmod(offset, 60)
                                zreplace = '%c%02d%02d' % (sign, h, m)
                    assert '%' not in zreplace
                    newformat.append(zreplace)
                elif ch == 'Z':
                    if Zreplace is None:
                        Zreplace = ""
                        if hasattr(object, "tzname"):
                            s = object.tzname()
                            if s is not None:
                                # strftime is going to have at this: escape %
                                Zreplace = s.replace('%', '%%')
                    newformat.append(Zreplace)
                else:
                    push('%')
                    push(ch)
            else:
                push('%')
        else:
            push(ch)
    newformat = "".join(newformat)
    return _time.strftime(newformat, timetuple)

def _call_tzinfo_method(tzinfo, methname, tzinfoarg):
    if tzinfo is None:
        return None
    return getattr(tzinfo, methname)(tzinfoarg)

def _check_tzname(name):
    if name is not None and not isinstance(name, str):
        raise TypeError("tzinfo.tzname() must return None or string, "
                        "not '%s'" % type(name))

def _check_utc_offset(name, offset):
    assert name in ("utcoffset", "dst")
    if offset is None:
        return None
    if not isinstance(offset, timedelta):
        raise TypeError("tzinfo.%s() must return None "
                        "or timedelta, not '%s'" % (name, type(offset)))
    days = offset.days
    if days < -1 or days > 0:
        offset = 1440  # trigger out-of-range
    else:
        seconds = days * 86400 + offset.seconds
        minutes, seconds = divmod(seconds, 60)
        if seconds or offset.microseconds:
            raise ValueError("tzinfo.%s() must return a whole number "
                             "of minutes" % name)
        offset = minutes
    if -1440 < offset < 1440:
        return offset
    raise ValueError("%s()=%d, must be in -1439..1439" % (name, offset))

def _check_date_fields(year, month, day):
    if not MINYEAR <= year <= MAXYEAR:
        raise ValueError('year must be in %d..%d' % (MINYEAR, MAXYEAR), year)
    if not 1 <= month <= 12:
        raise ValueError('month must be in 1..12', month)
    dim = _days_in_month(year, month)
    if not 1 <= day <= dim:
        raise ValueError('day must be in 1..%d' % dim, day)

def _check_time_fields(hour, minute, second, microsecond):
    if not 0 <= hour <= 23:
        raise ValueError('hour must be in 0..23', hour)
    if not 0 <= minute <= 59:
        raise ValueError('minute must be in 0..59', minute)
    if not 0 <= second <= 59:
        raise ValueError('second must be in 0..59', second)
    if not 0 <= microsecond <= 999999:
        raise ValueError('microsecond must be in 0..999999', microsecond)

def _check_tzinfo_arg(tz):
    if tz is not None and not isinstance(tz, tzinfo):
        raise TypeError("tzinfo argument must be None or of a tzinfo subclass")


def _cmperror(x, y):
    raise TypeError("can't compare '%s' to '%s'" % (
                    type(x).__name__, type(y).__name__))

_ORD1970 = _ymd2ord(1970, 1, 1) # base ordinal for UNIX epoch

class tmxxx:

    ordinal = None

    def __init__(self, year, month, day, hour=0, minute=0, second=0,
                 microsecond=0):
        # Normalize all the inputs, and store the normalized values.
        if not 0 <= microsecond <= 999999:
            carry, microsecond = divmod(microsecond, 1000000)
            second += carry
        if not 0 <= second <= 59:
            carry, second = divmod(second, 60)
            minute += carry
        if not 0 <= minute <= 59:
            carry, minute = divmod(minute, 60)
            hour += carry
        if not 0 <= hour <= 23:
            carry, hour = divmod(hour, 24)
            day += carry

        if not 1 <= month <= 12:
            carry, month = divmod(month-1, 12)
            year += carry
            month += 1
            assert 1 <= month <= 12

        dim = _days_in_month(year, month)
        if not 1 <= day <= dim:
            if day == 0:    # move back a day
                month -= 1
                if month > 0:
                    day = _days_in_month(year, month)
                else:
                    year, month, day = year-1, 12, 31
            elif day == dim + 1:    # move forward a day
                month += 1
                day = 1
                if month > 12:
                    month = 1
                    year += 1
            else:
                self.ordinal = _ymd2ord(year, month, 1) + (day - 1)
                year, month, day = _ord2ymd(self.ordinal)

        self.year, self.month, self.day = year, month, day
        self.hour, self.minute, self.second = hour, minute, second
        self.microsecond = microsecond

    def toordinal(self):
        if self.ordinal is None:
            self.ordinal = _ymd2ord(self.year, self.month, self.day)
        return self.ordinal

    def time(self):
        days = self.toordinal() - _ORD1970   # convert to UNIX epoch
        seconds = ((days * 24. + self.hour)*60. + self.minute)*60.
        return seconds + self.second + self.microsecond / 1e6

    def ctime(self):
        weekday = self.toordinal() % 7 or 7
        return "%s %s %2d %02d:%02d:%02d %04d" % (
            _DAYNAMES[weekday],
            _MONTHNAMES[self.month],
            self.day,
            self.hour, self.minute, self.second,
            self.year)

class timedelta(object):
    def __new__(cls, days=0, seconds=0, microseconds=0,
                # XXX The following should only be used as keyword args:
                milliseconds=0, minutes=0, hours=0, weeks=0):
        d = s = us = 0

        days += weeks*7
        seconds += minutes*60 + hours*3600
        microseconds += milliseconds*1000

        if isinstance(days, float):
            dayfrac, days = _math.modf(days)
            daysecondsfrac, daysecondswhole = _math.modf(dayfrac * (24.*3600.))
            assert daysecondswhole == int(daysecondswhole)  # can't overflow
            s = int(daysecondswhole)
            assert days == long(days)
            d = long(days)
        else:
            daysecondsfrac = 0.0
            d = days
        assert isinstance(daysecondsfrac, float)
        assert abs(daysecondsfrac) <= 1.0
        assert isinstance(d, (int, long))
        assert abs(s) <= 24 * 3600

        if isinstance(seconds, float):
            secondsfrac, seconds = _math.modf(seconds)
            assert seconds == long(seconds)
            seconds = long(seconds)
            secondsfrac += daysecondsfrac
            assert abs(secondsfrac) <= 2.0
        else:
            secondsfrac = daysecondsfrac
        assert isinstance(secondsfrac, float)
        assert abs(secondsfrac) <= 2.0

        assert isinstance(seconds, (int, long))
        days, seconds = divmod(seconds, 24*3600)
        d += days
        s += int(seconds)    # can't overflow
        assert isinstance(s, int)
        assert abs(s) <= 2 * 24 * 3600

        usdouble = secondsfrac * 1e6
        assert abs(usdouble) < 2.1e6    # exact value not critical

        if isinstance(microseconds, float):
            microseconds += usdouble
            microseconds = round(microseconds)
            seconds, microseconds = divmod(microseconds, 1e6)
            assert microseconds == int(microseconds)
            assert seconds == long(seconds)
            days, seconds = divmod(seconds, 24.*3600.)
            assert days == long(days)
            assert seconds == int(seconds)
            d += long(days)
            s += int(seconds)   # can't overflow
            assert isinstance(s, int)
            assert abs(s) <= 3 * 24 * 3600
        else:
            seconds, microseconds = divmod(microseconds, 1000000)
            days, seconds = divmod(seconds, 24*3600)
            d += days
            s += int(seconds)    # can't overflow
            assert isinstance(s, int)
            assert abs(s) <= 3 * 24 * 3600
            microseconds = float(microseconds)
            microseconds += usdouble
            microseconds = round(microseconds)
        assert abs(s) <= 3 * 24 * 3600
        assert abs(microseconds) < 3.1e6

        assert isinstance(microseconds, float)
        assert int(microseconds) == microseconds
        us = int(microseconds)
        seconds, us = divmod(us, 1000000)
        s += seconds    # cant't overflow
        assert isinstance(s, int)
        days, s = divmod(s, 24*3600)
        d += days

        assert isinstance(d, (int, long))
        assert isinstance(s, int) and 0 <= s < 24*3600
        assert isinstance(us, int) and 0 <= us < 1000000

        self = object.__new__(cls)

        self.__days = d
        self.__seconds = s
        self.__microseconds = us
        if abs(d) > 999999999:
            raise OverflowError("timedelta # of days is too large: %d" % d)

        return self

    def __repr__(self):
        if self.__microseconds:
            return "%s(%d, %d, %d)" % ('datetime.' + self.__class__.__name__,
                                       self.__days,
                                       self.__seconds,
                                       self.__microseconds)
        if self.__seconds:
            return "%s(%d, %d)" % ('datetime.' + self.__class__.__name__,
                                   self.__days,
                                   self.__seconds)
        return "%s(%d)" % ('datetime.' + self.__class__.__name__, self.__days)

    def __str__(self):
        mm, ss = divmod(self.__seconds, 60)
        hh, mm = divmod(mm, 60)
        s = "%d:%02d:%02d" % (hh, mm, ss)
        if self.__days:
            def plural(n):
                return n, abs(n) != 1 and "s" or ""
            s = ("%d day%s, " % plural(self.__days)) + s
        if self.__microseconds:
            s = s + ".%06d" % self.__microseconds
        return s

    days = property(lambda self: self.__days, doc="days")
    seconds = property(lambda self: self.__seconds, doc="seconds")
    microseconds = property(lambda self: self.__microseconds,
                            doc="microseconds")

    def __add__(self, other):
        if isinstance(other, timedelta):
            # for CPython compatibility, we cannot use
            # our __class__ here, but need a real timedelta
            return timedelta(self.__days + other.__days,
                             self.__seconds + other.__seconds,
                             self.__microseconds + other.__microseconds)
        return NotImplemented

    __radd__ = __add__

    def __sub__(self, other):
        if isinstance(other, timedelta):
            return self + -other
        return NotImplemented

    def __rsub__(self, other):
        if isinstance(other, timedelta):
            return -self + other
        return NotImplemented

    def __neg__(self):
            # for CPython compatibility, we cannot use
            # our __class__ here, but need a real timedelta
        return timedelta(-self.__days,
                         -self.__seconds,
                         -self.__microseconds)

    def __pos__(self):
        return self

    def __abs__(self):
        if self.__days < 0:
            return -self
        else:
            return self

    def __mul__(self, other):
        if isinstance(other, (int, long)):
            # for CPython compatibility, we cannot use
            # our __class__ here, but need a real timedelta
            return timedelta(self.__days * other,
                             self.__seconds * other,
                             self.__microseconds * other)
        return NotImplemented

    __rmul__ = __mul__

    def __div__(self, other):
        if isinstance(other, (int, long)):
            usec = ((self.__days * (24*3600L) + self.__seconds) * 1000000 +
                    self.__microseconds)
            return timedelta(0, 0, usec // other)
        return NotImplemented

    __floordiv__ = __div__

    def __eq__(self, other):
        if isinstance(other, timedelta):
            return self.__cmp(other) == 0
        else:
            return False

    def __ne__(self, other):
        if isinstance(other, timedelta):
            return self.__cmp(other) != 0
        else:
            return True

    def __le__(self, other):
        if isinstance(other, timedelta):
            return self.__cmp(other) <= 0
        else:
            _cmperror(self, other)

    def __lt__(self, other):
        if isinstance(other, timedelta):
            return self.__cmp(other) < 0
        else:
            _cmperror(self, other)

    def __ge__(self, other):
        if isinstance(other, timedelta):
            return self.__cmp(other) >= 0
        else:
            _cmperror(self, other)

    def __gt__(self, other):
        if isinstance(other, timedelta):
            return self.__cmp(other) > 0
        else:
            _cmperror(self, other)

    def __cmp(self, other):
        assert isinstance(other, timedelta)
        return cmp(self.__getstate(), other.__getstate())

    def __hash__(self):
        return hash(self.__getstate())

    def __nonzero__(self):
        return (self.__days != 0 or
                self.__seconds != 0 or
                self.__microseconds != 0)

    # Pickle support.

    __safe_for_unpickling__ = True      # For Python 2.2

    def __getstate(self):
        return (self.__days, self.__seconds, self.__microseconds)

    def __reduce__(self):
        return (self.__class__, self.__getstate())

timedelta.min = timedelta(-999999999)
timedelta.max = timedelta(days=999999999, hours=23, minutes=59, seconds=59,
                          microseconds=999999)
timedelta.resolution = timedelta(microseconds=1)

class date(object):

    def __new__(cls, year, month=None, day=None):
        if isinstance(year, str):
            # Pickle support
            self = object.__new__(cls)
            self.__setstate(year)
            return self
        _check_date_fields(year, month, day)
        self = object.__new__(cls)
        self.__year = year
        self.__month = month
        self.__day = day
        return self


    def fromtimestamp(cls, t):
        y, m, d, hh, mm, ss, weekday, jday, dst = _time.localtime(t)
        return cls(y, m, d)
    fromtimestamp = classmethod(fromtimestamp)

    def today(cls):
        t = _time.time()
        return cls.fromtimestamp(t)
    today = classmethod(today)

    def fromordinal(cls, n):
        y, m, d = _ord2ymd(n)
        return cls(y, m, d)
    fromordinal = classmethod(fromordinal)

    # Conversions to string

    def __repr__(self):
        return "%s(%d, %d, %d)" % ('datetime.' + self.__class__.__name__,
                                   self.__year,
                                   self.__month,
                                   self.__day)
    def ctime(self):
        return tmxxx(self.__year, self.__month, self.__day).ctime()

    def strftime(self, fmt):
        return _wrap_strftime(self, fmt, self.timetuple())

    def isoformat(self):
        return "%04d-%02d-%02d" % (self.__year, self.__month, self.__day)

    __str__ = isoformat

    year = property(lambda self: self.__year,
                    doc="year (%d-%d)" % (MINYEAR, MAXYEAR))
    month = property(lambda self: self.__month, doc="month (1-12)")
    day = property(lambda self: self.__day, doc="day (1-31)")

    def timetuple(self):
        return _build_struct_time(self.__year, self.__month, self.__day,
                                  0, 0, 0, -1)

    def toordinal(self):
        return _ymd2ord(self.__year, self.__month, self.__day)

    def replace(self, year=None, month=None, day=None):
        if year is None:
            year = self.__year
        if month is None:
            month = self.__month
        if day is None:
            day = self.__day
        _check_date_fields(year, month, day)
        return date(year, month, day)

    def __eq__(self, other):
        if isinstance(other, date):
            return self.__cmp(other) == 0
        elif hasattr(other, "timetuple"):
            return NotImplemented
        else:
            return False

    def __ne__(self, other):
        if isinstance(other, date):
            return self.__cmp(other) != 0
        elif hasattr(other, "timetuple"):
            return NotImplemented
        else:
            return True

    def __le__(self, other):
        if isinstance(other, date):
            return self.__cmp(other) <= 0
        elif hasattr(other, "timetuple"):
            return NotImplemented
        else:
            _cmperror(self, other)

    def __lt__(self, other):
        if isinstance(other, date):
            return self.__cmp(other) < 0
        elif hasattr(other, "timetuple"):
            return NotImplemented
        else:
            _cmperror(self, other)

    def __ge__(self, other):
        if isinstance(other, date):
            return self.__cmp(other) >= 0
        elif hasattr(other, "timetuple"):
            return NotImplemented
        else:
            _cmperror(self, other)

    def __gt__(self, other):
        if isinstance(other, date):
            return self.__cmp(other) > 0
        elif hasattr(other, "timetuple"):
            return NotImplemented
        else:
            _cmperror(self, other)

    def __cmp(self, other):
        assert isinstance(other, date)
        y, m, d = self.__year, self.__month, self.__day
        y2, m2, d2 = other.__year, other.__month, other.__day
        return cmp((y, m, d), (y2, m2, d2))

    def __hash__(self):
        "Hash."
        return hash(self.__getstate())


    def _checkOverflow(self, year):
        if not MINYEAR <= year <= MAXYEAR:
            raise OverflowError("date +/-: result year %d not in %d..%d" %
                                (year, MINYEAR, MAXYEAR))

    def __add__(self, other):
        "Add a date to a timedelta."
        if isinstance(other, timedelta):
            t = tmxxx(self.__year,
                      self.__month,
                      self.__day + other.days)
            self._checkOverflow(t.year)
            result = date(t.year, t.month, t.day)
            return result
        raise TypeError
    __radd__ = __add__

    def __sub__(self, other):
        """Subtract two dates, or a date and a timedelta."""
        if isinstance(other, timedelta):
            return self + timedelta(-other.days)
        if isinstance(other, date):
            days1 = self.toordinal()
            days2 = other.toordinal()
            return timedelta(days1 - days2)
        return NotImplemented

    def weekday(self):
        return (self.toordinal() + 6) % 7


    def isoweekday(self):
        return self.toordinal() % 7 or 7

    def isocalendar(self):
        year = self.__year
        week1monday = _isoweek1monday(year)
        today = _ymd2ord(self.__year, self.__month, self.__day)
        week, day = divmod(today - week1monday, 7)
        if week < 0:
            year -= 1
            week1monday = _isoweek1monday(year)
            week, day = divmod(today - week1monday, 7)
        elif week >= 52:
            if today >= _isoweek1monday(year+1):
                year += 1
                week = 0
        return year, week+1, day+1


    __safe_for_unpickling__ = True      # For Python 2.2

    def __getstate(self):
        yhi, ylo = divmod(self.__year, 256)
        return ("%c%c%c%c" % (yhi, ylo, self.__month, self.__day), )

    def __setstate(self, string):
        if len(string) != 4 or not (1 <= ord(string[2]) <= 12):
            raise TypeError("not enough arguments")
        yhi, ylo, self.__month, self.__day = map(ord, string)
        self.__year = yhi * 256 + ylo

    def __reduce__(self):
        return (self.__class__, self.__getstate())

    if _sys.platform.startswith('java'):
        def __tojava__(self, java_class):
            if java_class not in (Calendar, Date, Object):
                return Py.NoConversion

            calendar = Calendar.getInstance()
            calendar.clear()
            calendar.set(self.year, self.month - 1, self.day)
            if java_class == Calendar:
                return calendar
            else:
                return Date(calendar.getTimeInMillis())


_date_class = date  # so functions w/ args named "date" can get at the class

date.min = date(1, 1, 1)
date.max = date(9999, 12, 31)
date.resolution = timedelta(days=1)

class tzinfo(object):
    def tzname(self, dt):
        raise NotImplementedError("tzinfo subclass must override tzname()")

    def utcoffset(self, dt):
        raise NotImplementedError("tzinfo subclass must override utcoffset()")

    def dst(self, dt):
        raise NotImplementedError("tzinfo subclass must override dst()")

    def fromutc(self, dt):
        if not isinstance(dt, datetime):
            raise TypeError("fromutc() requires a datetime argument")
        if dt.tzinfo is not self:
            raise ValueError("dt.tzinfo is not self")

        dtoff = dt.utcoffset()
        if dtoff is None:
            raise ValueError("fromutc() requires a non-None utcoffset() "
                             "result")

        dtdst = dt.dst()
        if dtdst is None:
            raise ValueError("fromutc() requires a non-None dst() result")
        delta = dtoff - dtdst
        if delta:
            dt += delta
            dtdst = dt.dst()
            if dtdst is None:
                raise ValueError("fromutc(): dt.dst gave inconsistent "
                                 "results; cannot convert")
        if dtdst:
            return dt + dtdst
        else:
            return dt

    __safe_for_unpickling__ = True      # For Python 2.2

    def __reduce__(self):
        getinitargs = getattr(self, "__getinitargs__", None)
        if getinitargs:
            args = getinitargs()
        else:
            args = ()
        getstate = getattr(self, "__getstate__", None)
        if getstate:
            state = getstate()
        else:
            state = getattr(self, "__dict__", None) or None
        if state is None:
            return (self.__class__, args)
        else:
            return (self.__class__, args, state)

_tzinfo_class = tzinfo   # so functions w/ args named "tinfo" can get at it

class time(object):

    def __new__(cls, hour=0, minute=0, second=0, microsecond=0, tzinfo=None):
        self = object.__new__(cls)
        if isinstance(hour, str):
            self.__setstate(hour, minute or None)
            return self
        _check_tzinfo_arg(tzinfo)
        _check_time_fields(hour, minute, second, microsecond)
        self.__hour = hour
        self.__minute = minute
        self.__second = second
        self.__microsecond = microsecond
        self._tzinfo = tzinfo
        return self

    hour = property(lambda self: self.__hour, doc="hour (0-23)")
    minute = property(lambda self: self.__minute, doc="minute (0-59)")
    second = property(lambda self: self.__second, doc="second (0-59)")
    microsecond = property(lambda self: self.__microsecond,
                           doc="microsecond (0-999999)")
    tzinfo = property(lambda self: self._tzinfo, doc="timezone info object")

    def __eq__(self, other):
        if isinstance(other, time):
            return self.__cmp(other) == 0
        else:
            return False

    def __ne__(self, other):
        if isinstance(other, time):
            return self.__cmp(other) != 0
        else:
            return True

    def __le__(self, other):
        if isinstance(other, time):
            return self.__cmp(other) <= 0
        else:
            _cmperror(self, other)

    def __lt__(self, other):
        if isinstance(other, time):
            return self.__cmp(other) < 0
        else:
            _cmperror(self, other)

    def __ge__(self, other):
        if isinstance(other, time):
            return self.__cmp(other) >= 0
        else:
            _cmperror(self, other)

    def __gt__(self, other):
        if isinstance(other, time):
            return self.__cmp(other) > 0
        else:
            _cmperror(self, other)

    def __cmp(self, other):
        assert isinstance(other, time)
        mytz = self._tzinfo
        ottz = other._tzinfo
        myoff = otoff = None

        if mytz is ottz:
            base_compare = True
        else:
            myoff = self._utcoffset()
            otoff = other._utcoffset()
            base_compare = myoff == otoff

        if base_compare:
            return cmp((self.__hour, self.__minute, self.__second,
                        self.__microsecond),
                       (other.__hour, other.__minute, other.__second,
                        other.__microsecond))
        if myoff is None or otoff is None:
            raise TypeError("cannot compare naive and aware times")
        myhhmm = self.__hour * 60 + self.__minute - myoff
        othhmm = other.__hour * 60 + other.__minute - otoff
        return cmp((myhhmm, self.__second, self.__microsecond),
                   (othhmm, other.__second, other.__microsecond))

    def __hash__(self):
        """Hash."""
        tzoff = self._utcoffset()
        if not tzoff: # zero or None
            return hash(self.__getstate()[0])
        h, m = divmod(self.hour * 60 + self.minute - tzoff, 60)
        if 0 <= h < 24:
            return hash(time(h, m, self.second, self.microsecond))
        return hash((h, m, self.second, self.microsecond))

    def _tzstr(self, sep=":"):
        """Return formatted timezone offset (+xx:xx) or None."""
        off = self._utcoffset()
        if off is not None:
            if off < 0:
                sign = "-"
                off = -off
            else:
                sign = "+"
            hh, mm = divmod(off, 60)
            assert 0 <= hh < 24
            off = "%s%02d%s%02d" % (sign, hh, sep, mm)
        return off

    def __repr__(self):
        """Convert to formal string, for repr()."""
        if self.__microsecond != 0:
            s = ", %d, %d" % (self.__second, self.__microsecond)
        elif self.__second != 0:
            s = ", %d" % self.__second
        else:
            s = ""
        s= "%s(%d, %d%s)" % ('datetime.' + self.__class__.__name__,
                             self.__hour, self.__minute, s)
        if self._tzinfo is not None:
            assert s[-1:] == ")"
            s = s[:-1] + ", tzinfo=%r" % self._tzinfo + ")"
        return s

    def isoformat(self):
        s = _format_time(self.__hour, self.__minute, self.__second,
                         self.__microsecond)
        tz = self._tzstr()
        if tz:
            s += tz
        return s

    __str__ = isoformat

    def strftime(self, fmt):
        timetuple = (1900, 1, 1,
                     self.__hour, self.__minute, self.__second,
                     0, 1, -1)
        return _wrap_strftime(self, fmt, timetuple)

    def utcoffset(self):
        offset = _call_tzinfo_method(self._tzinfo, "utcoffset", None)
        offset = _check_utc_offset("utcoffset", offset)
        if offset is not None:
            offset = timedelta(minutes=offset)
        return offset

    def _utcoffset(self):
        offset = _call_tzinfo_method(self._tzinfo, "utcoffset", None)
        offset = _check_utc_offset("utcoffset", offset)
        return offset

    def tzname(self):
        name = _call_tzinfo_method(self._tzinfo, "tzname", None)
        _check_tzname(name)
        return name

    def dst(self):
        offset = _call_tzinfo_method(self._tzinfo, "dst", None)
        offset = _check_utc_offset("dst", offset)
        if offset is not None:
            offset = timedelta(minutes=offset)
        return offset

    def replace(self, hour=None, minute=None, second=None, microsecond=None,
                tzinfo=True):
        if hour is None:
            hour = self.hour
        if minute is None:
            minute = self.minute
        if second is None:
            second = self.second
        if microsecond is None:
            microsecond = self.microsecond
        if tzinfo is True:
            tzinfo = self.tzinfo
        _check_time_fields(hour, minute, second, microsecond)
        _check_tzinfo_arg(tzinfo)
        return time(hour, minute, second, microsecond, tzinfo)

    def _dst(self):
        offset = _call_tzinfo_method(self._tzinfo, "dst", None)
        offset = _check_utc_offset("dst", offset)
        return offset

    def __nonzero__(self):
        if self.second or self.microsecond:
            return 1
        offset = self._utcoffset() or 0
        return self.hour * 60 + self.minute - offset != 0

    __safe_for_unpickling__ = True      # For Python 2.2

    def __getstate(self):
        us2, us3 = divmod(self.__microsecond, 256)
        us1, us2 = divmod(us2, 256)
        basestate = ("%c" * 6) % (self.__hour, self.__minute, self.__second,
                                  us1, us2, us3)
        if self._tzinfo is None:
            return (basestate,)
        else:
            return (basestate, self._tzinfo)

    def __setstate(self, string, tzinfo):
        if len(string) != 6 or ord(string[0]) >= 24:
            raise TypeError("an integer is required")
        self.__hour, self.__minute, self.__second, us1, us2, us3 = \
                                                            map(ord, string)
        self.__microsecond = (((us1 << 8) | us2) << 8) | us3
        self._tzinfo = tzinfo

    def __reduce__(self):
        return (time, self.__getstate())

    if _sys.platform.startswith('java'):
        def __tojava__(self, java_class):
            # TODO, if self.tzinfo is not None, convert time to UTC
            if java_class not in (Calendar, Time, Object):
                return Py.NoConversion

            calendar = Calendar.getInstance()
            calendar.clear()
            calendar.set(Calendar.HOUR_OF_DAY, self.hour)
            calendar.set(Calendar.MINUTE, self.minute)
            calendar.set(Calendar.SECOND, self.second)
            calendar.set(Calendar.MILLISECOND, self.microsecond // 1000)
            if java_class == Calendar:
                return calendar
            else:
                return Time(calendar.getTimeInMillis())


_time_class = time  # so functions w/ args named "time" can get at the class

time.min = time(0, 0, 0)
time.max = time(23, 59, 59, 999999)
time.resolution = timedelta(microseconds=1)

class datetime(date):

    def __new__(cls, year, month=None, day=None, hour=0, minute=0, second=0,
                microsecond=0, tzinfo=None):
        if isinstance(year, str):
            # Pickle support
            self = date.__new__(cls, year[:4])
            self.__setstate(year, month)
            return self
        _check_tzinfo_arg(tzinfo)
        _check_time_fields(hour, minute, second, microsecond)
        self = date.__new__(cls, year, month, day)
        # XXX This duplicates __year, __month, __day for convenience :-(
        self.__year = year
        self.__month = month
        self.__day = day
        self.__hour = hour
        self.__minute = minute
        self.__second = second
        self.__microsecond = microsecond
        self._tzinfo = tzinfo
        return self

    # Read-only field accessors
    hour = property(lambda self: self.__hour, doc="hour (0-23)")
    minute = property(lambda self: self.__minute, doc="minute (0-59)")
    second = property(lambda self: self.__second, doc="second (0-59)")
    microsecond = property(lambda self: self.__microsecond,
                           doc="microsecond (0-999999)")
    tzinfo = property(lambda self: self._tzinfo, doc="timezone info object")

    def fromtimestamp(cls, t, tz=None):

        _check_tzinfo_arg(tz)
        if tz is None:
            converter = _time.localtime
        else:
            converter = _time.gmtime
        y, m, d, hh, mm, ss, weekday, jday, dst = converter(t)
        us = int((t % 1.0) * 1000000)

        if us == 1000001 or us == 999999:
            us = 0
            rounded = True
        else:
            rounded = False

        ss = min(ss, 59)    # clamp out leap seconds if the platform has them
        result = cls(y, m, d, hh, mm, ss, us, tz)
        if rounded:
            result += timedelta(seconds=1)
        if tz is not None:
            result = tz.fromutc(result)
        return result
    fromtimestamp = classmethod(fromtimestamp)

    def utcfromtimestamp(cls, t):
        y, m, d, hh, mm, ss, weekday, jday, dst = _time.gmtime(t)
        us = int((t % 1.0) * 1000000)
        ss = min(ss, 59)    # clamp out leap seconds if the platform has them
        return cls(y, m, d, hh, mm, ss, us)
    utcfromtimestamp = classmethod(utcfromtimestamp)

    def now(cls, tz=None):
        t = _time.time()
        return cls.fromtimestamp(t, tz)
    now = classmethod(now)

    def utcnow(cls):
        t = _time.time()
        return cls.utcfromtimestamp(t)
    utcnow = classmethod(utcnow)

    def combine(cls, date, time):
        if not isinstance(date, _date_class):
            raise TypeError("date argument must be a date instance")
        if not isinstance(time, _time_class):
            raise TypeError("time argument must be a time instance")
        return cls(date.year, date.month, date.day,
                   time.hour, time.minute, time.second, time.microsecond,
                   time.tzinfo)
    combine = classmethod(combine)

    def strptime(cls, date_string, format):
        return cls(*(_time.strptime(date_string, format))[0:6])

    strptime = classmethod(strptime)

    def timetuple(self):
        dst = self._dst()
        if dst is None:
            dst = -1
        elif dst:
            dst = 1
        return _build_struct_time(self.year, self.month, self.day,
                                  self.hour, self.minute, self.second,
                                  dst)

    def utctimetuple(self):
        y, m, d = self.year, self.month, self.day
        hh, mm, ss = self.hour, self.minute, self.second
        offset = self._utcoffset()
        if offset:  # neither None nor 0
            tm = tmxxx(y, m, d, hh, mm - offset)
            y, m, d = tm.year, tm.month, tm.day
            hh, mm = tm.hour, tm.minute
        return _build_struct_time(y, m, d, hh, mm, ss, 0)

    def date(self):
        return date(self.__year, self.__month, self.__day)

    def time(self):
        return time(self.hour, self.minute, self.second, self.microsecond)

    def timetz(self):
        return time(self.hour, self.minute, self.second, self.microsecond,
                    self._tzinfo)

    def replace(self, year=None, month=None, day=None, hour=None,
                minute=None, second=None, microsecond=None, tzinfo=True):
        if year is None:
            year = self.year
        if month is None:
            month = self.month
        if day is None:
            day = self.day
        if hour is None:
            hour = self.hour
        if minute is None:
            minute = self.minute
        if second is None:
            second = self.second
        if microsecond is None:
            microsecond = self.microsecond
        if tzinfo is True:
            tzinfo = self.tzinfo
        _check_date_fields(year, month, day)
        _check_time_fields(hour, minute, second, microsecond)
        _check_tzinfo_arg(tzinfo)
        return datetime(year, month, day, hour, minute, second,
                          microsecond, tzinfo)

    def astimezone(self, tz):
        if not isinstance(tz, tzinfo):
            raise TypeError("tz argument must be an instance of tzinfo")

        mytz = self.tzinfo
        if mytz is None:
            raise ValueError("astimezone() requires an aware datetime")

        if tz is mytz:
            return self

        myoffset = self.utcoffset()
        if myoffset is None:
            raise ValueError("astimezone() requires an aware datetime")
        utc = (self - myoffset).replace(tzinfo=tz)

        return tz.fromutc(utc)

    def ctime(self):
        "Format a la ctime()."
        t = tmxxx(self.__year, self.__month, self.__day, self.__hour,
                  self.__minute, self.__second)
        return t.ctime()

    def isoformat(self, sep='T'):
        s = ("%04d-%02d-%02d%c" % (self.__year, self.__month, self.__day,
                                  sep) +
                _format_time(self.__hour, self.__minute, self.__second,
                             self.__microsecond))
        off = self._utcoffset()
        if off is not None:
            if off < 0:
                sign = "-"
                off = -off
            else:
                sign = "+"
            hh, mm = divmod(off, 60)
            s += "%s%02d:%02d" % (sign, hh, mm)
        return s

    def __repr__(self):
        "Convert to formal string, for repr()."
        L = [self.__year, self.__month, self.__day, # These are never zero
             self.__hour, self.__minute, self.__second, self.__microsecond]
        if L[-1] == 0:
            del L[-1]
        if L[-1] == 0:
            del L[-1]
        s = ", ".join(map(str, L))
        s = "%s(%s)" % ('datetime.' + self.__class__.__name__, s)
        if self._tzinfo is not None:
            assert s[-1:] == ")"
            s = s[:-1] + ", tzinfo=%r" % self._tzinfo + ")"
        return s

    def __str__(self):
        return self.isoformat(sep=' ')

    def utcoffset(self):
        offset = _call_tzinfo_method(self._tzinfo, "utcoffset", self)
        offset = _check_utc_offset("utcoffset", offset)
        if offset is not None:
            offset = timedelta(minutes=offset)
        return offset

    def _utcoffset(self):
        offset = _call_tzinfo_method(self._tzinfo, "utcoffset", self)
        offset = _check_utc_offset("utcoffset", offset)
        return offset

    def tzname(self):
        name = _call_tzinfo_method(self._tzinfo, "tzname", self)
        _check_tzname(name)
        return name

    def dst(self):
        offset = _call_tzinfo_method(self._tzinfo, "dst", self)
        offset = _check_utc_offset("dst", offset)
        if offset is not None:
            offset = timedelta(minutes=offset)
        return offset

    def _dst(self):
        offset = _call_tzinfo_method(self._tzinfo, "dst", self)
        offset = _check_utc_offset("dst", offset)
        return offset

    def __eq__(self, other):
        if isinstance(other, datetime):
            return self.__cmp(other) == 0
        elif hasattr(other, "timetuple") and not isinstance(other, date):
            return NotImplemented
        else:
            return False

    def __ne__(self, other):
        if isinstance(other, datetime):
            return self.__cmp(other) != 0
        elif hasattr(other, "timetuple") and not isinstance(other, date):
            return NotImplemented
        else:
            return True

    def __le__(self, other):
        if isinstance(other, datetime):
            return self.__cmp(other) <= 0
        elif hasattr(other, "timetuple") and not isinstance(other, date):
            return NotImplemented
        else:
            _cmperror(self, other)

    def __lt__(self, other):
        if isinstance(other, datetime):
            return self.__cmp(other) < 0
        elif hasattr(other, "timetuple") and not isinstance(other, date):
            return NotImplemented
        else:
            _cmperror(self, other)

    def __ge__(self, other):
        if isinstance(other, datetime):
            return self.__cmp(other) >= 0
        elif hasattr(other, "timetuple") and not isinstance(other, date):
            return NotImplemented
        else:
            _cmperror(self, other)

    def __gt__(self, other):
        if isinstance(other, datetime):
            return self.__cmp(other) > 0
        elif hasattr(other, "timetuple") and not isinstance(other, date):
            return NotImplemented
        else:
            _cmperror(self, other)

    def __cmp(self, other):
        assert isinstance(other, datetime)
        mytz = self._tzinfo
        ottz = other._tzinfo
        myoff = otoff = None

        if mytz is ottz:
            base_compare = True
        else:
            if mytz is not None:
                myoff = self._utcoffset()
            if ottz is not None:
                otoff = other._utcoffset()
            base_compare = myoff == otoff

        if base_compare:
            return cmp((self.__year, self.__month, self.__day,
                        self.__hour, self.__minute, self.__second,
                        self.__microsecond),
                       (other.__year, other.__month, other.__day,
                        other.__hour, other.__minute, other.__second,
                        other.__microsecond))
        if myoff is None or otoff is None:
            raise TypeError("cannot compare naive and aware datetimes")
        diff = self - other     # this will take offsets into account
        if diff.days < 0:
            return -1
        return diff and 1 or 0

    def __add__(self, other):
        if not isinstance(other, timedelta):
            return NotImplemented
        t = tmxxx(self.__year,
                  self.__month,
                  self.__day + other.days,
                  self.__hour,
                  self.__minute,
                  self.__second + other.seconds,
                  self.__microsecond + other.microseconds)
        self._checkOverflow(t.year)
        result = datetime(t.year, t.month, t.day,
                                t.hour, t.minute, t.second,
                                t.microsecond, tzinfo=self._tzinfo)
        return result

    __radd__ = __add__

    def __sub__(self, other):
        if not isinstance(other, datetime):
            if isinstance(other, timedelta):
                return self + -other
            return NotImplemented

        days1 = self.toordinal()
        days2 = other.toordinal()
        secs1 = self.__second + self.__minute * 60 + self.__hour * 3600
        secs2 = other.__second + other.__minute * 60 + other.__hour * 3600
        base = timedelta(days1 - days2,
                         secs1 - secs2,
                         self.__microsecond - other.__microsecond)
        if self._tzinfo is other._tzinfo:
            return base
        myoff = self._utcoffset()
        otoff = other._utcoffset()
        if myoff == otoff:
            return base
        if myoff is None or otoff is None:
            raise TypeError, "cannot mix naive and timezone-aware time"
        return base + timedelta(minutes = otoff-myoff)

    def __hash__(self):
        tzoff = self._utcoffset()
        if tzoff is None:
            return hash(self.__getstate()[0])
        days = _ymd2ord(self.year, self.month, self.day)
        seconds = self.hour * 3600 + (self.minute - tzoff) * 60 + self.second
        return hash(timedelta(days, seconds, self.microsecond))

    __safe_for_unpickling__ = True      # For Python 2.2

    def __getstate(self):
        yhi, ylo = divmod(self.__year, 256)
        us2, us3 = divmod(self.__microsecond, 256)
        us1, us2 = divmod(us2, 256)
        basestate = ("%c" * 10) % (yhi, ylo, self.__month, self.__day,
                                   self.__hour, self.__minute, self.__second,
                                   us1, us2, us3)
        if self._tzinfo is None:
            return (basestate,)
        else:
            return (basestate, self._tzinfo)

    def __setstate(self, string, tzinfo):
        (yhi, ylo, self.__month, self.__day, self.__hour,
         self.__minute, self.__second, us1, us2, us3) = map(ord, string)
        self.__year = yhi * 256 + ylo
        self.__microsecond = (((us1 << 8) | us2) << 8) | us3
        self._tzinfo = tzinfo

    def __reduce__(self):
        return (self.__class__, self.__getstate())

    if _sys.platform.startswith('java'):
        def __tojava__(self, java_class):
            if java_class not in (Calendar, Timestamp, Object):
                return Py.NoConversion

            calendar = Calendar.getInstance()
            calendar.clear()
            calendar.set(self.year, self.month - 1, self.day,
                         self.hour, self.minute, self.second)

            if java_class == Calendar:
                calendar.set(Calendar.MILLISECOND, self.microsecond // 1000)
                return calendar
            else:
                timestamp = Timestamp(calendar.getTimeInMillis())
                timestamp.setNanos(self.microsecond * 1000)
                return timestamp


datetime.min = datetime(1, 1, 1)
datetime.max = datetime(9999, 12, 31, 23, 59, 59, 999999)
datetime.resolution = timedelta(microseconds=1)


def _isoweek1monday(year):
    THURSDAY = 3
    firstday = _ymd2ord(year, 1, 1)
    firstweekday = (firstday + 6) % 7 # See weekday() above
    week1monday = firstday - firstweekday
    if firstweekday > THURSDAY:
        week1monday += 7
    return week1monday

_webFormParamsProvided__ = False
import sys
import math

formParams = []
def defineFormParam(k, v):
  formParams.append(k)
  if k not in globals():
    if not _webFormParamsProvided__:
      globals()[k] = v
    else:
      raise Exception("value for %s not overriden"%k)

def nonFormParamGlobals():
    return [(k,v) for (k,v) in globals().items() if k not in formParams]

def eq(x):
    return x

def ceiling(x):
    return int(math.ceil(x))

def materialize(prefix, ehm, colCode, colValue, f=eq):
    for i in range(ehm.len()):
        code  = ehm[i+1].f(colCode)
        value = f(ehm[i+1].f(colValue))
        globalName = prefix+code
        globals()[globalName]=value
        u.println('declared global %s with value: %s' % (globalName, value))


def N2N(v, *f):
  if v is None:
    return 'null'
  elif type(v) is str:
    return '\''+v+'\''
  elif type(v) is unicode:
    return '\''+v+'\''
  elif not f:
    return v
  else:
    if type(v) is datetime:
        return v.strftime(f[0])
    else:
        return f[0]%v


def NVL(v, default):
 if (v==None):
  return default
 else:
  return v

def NVLZ(v):
 return NVL(v, 0)

class MyRecord:
    def __init__(self, dictData, calledFromSqlS=False):
        self._dictData = dictData
        if calledFromSqlS:
            for k in dictData.internal.keySet():
                kUpper = k.upper()
                globals()[kUpper]=dictData.f(k)
    def __getattr__(self, nameOfField):
        return self._dictData.f(nameOfField)
    def __getitem__(self, idx):
        return self._dictData[idx]
    def keys(self):
        return self._dictData.keySet()
    def keysN(self):
        return self._dictData.internal.keySet()
    def f(self, name):
        return self._dictData.f(name)

class MySQLrecords:
    def __init__(self, sqlData):
        self._results = sqlData
    def __getitem__(self, idx):
        return MyRecord(self._results[idx])
    def len(self):
        return self._results.size()

def sqlm(query, num=200000, panicIfLess=False, panicIfMore=False):
    return MySQLrecords(sql.sqlm(query, num, panicIfLess, panicIfMore))

def sqls(query):
    return MyRecord(sql.sqls(query), True)
def AnyToString(foo):
    if foo is None:
        return None
    else:
        return unicode(foo)

def sql_exec(stmtStr):
    return sql.sqlExec(stmtStr)

def accum(d, k, v):
    if k not in d.keys():
        d[k]=0
    d[k]+=v

I_peri_id = 1
I_comp_id = 1
D_date_from = date(2012, 01, 1)
###I_year = D_date_from.year %100
###I_month= D_date_from.month
###I_day  = D_date_from.day
###D_date_to = date.today()
D_date_to =date(2012, 03, 31)
######I_rtfe_session_id = 10
####I_rtfh_id = 8
#####I_last_rfch_id =0
#####I_liquidation_rfch_id = 0
######I_increment_percent = 0
I_rerp_id = 1
I_modifiable = 0
B_has_dosage = False
I_payment_value = 0
I_external  = 4
I_month_intra  = 12
STR_exempt ='APPALAGH LOGV MH 2012'
B_reserved = True
I_modifiable = 1
########################################
################ rd company info #####################
comp_sqls = """
SELECT *
FROM v_comp_all
WHERE COMP_ID=%d
"""
##############################
#  master e3  #
##############################
reem_sqlm = """
SELECT *
  FROM ER_RE_E3_MASTER
  WHERE PERI_ID =%d
"""
##############################
#  tax office  #
##############################
taof_sqlm = """
SELECT *
  FROM ER_TAX_OFFICES
  WHERE TAOF_ID =%d
"""
##############################
#  kaad   #
##############################
cooa_sqlm = """
SELECT *
  FROM ER_CODE_OF_ACTIVITIES
  WHERE COOA_ID =%d
"""
##############################
# EKDOTHENTA STOIXEIA       #
##############################
reei_sqlm = """
SELECT REEI_DESCRIPTION,
REEI_FROM_NUMBER,
REEI_TO_NUMBER
  FROM ER_RE_E3_INVOICES
  WHERE REEM_ID =%d 
  limit 10
"""
###########################
#  representative_info     #
############################
rerp_sqls = """
SELECT
* 
from v_er_re_representative_info
WHERE COMP_ID = %d
AND RERP_ID =%d  
"""
############################
#  REV_EXP VALUES          #
############################
p_rev_exp_sqlm = """
SELECT
SUM (retd_net_value) retd_net_value,
SUM (retd_vat_value) retd_vat_value,
SUM (retd_gross_value) retd_gross_value 
FROM v_e3_values 
WHERE PERI_ID = %d
AND reth_issue_date BETWEEN \'%s\' AND \'%s\'
AND ratf_code =\'%s\'   
"""
############################
#  mskk VALUES          #
############################
p_mskk_sqlm = """
SELECT rnpc_code,rnpc_percent,
sum( retd.retd_net_value ) AS retd_net_value,
sum( retd.retd_vat_value ) AS retd_vat_value,
sum( retd.retd_gross_value ) AS retd_gross_value
FROM 
er_re_tran_details retd,
er_re_net_profit_codes rnpc,
er_re_accounts reac,
er_re_tran_headers reth
WHERE reac.PERI_ID = %d
AND reth.peri_id = reac.peri_id
AND reth_issue_date BETWEEN \'%s\' AND \'%s\'
AND retd.reth_id = reth.reth_id
AND retd.reac_id = reac.reac_id 
AND reac.rnpc_id is not null
and rnpc.rnpc_id = reac.rnpc_id
GROUP BY rnpc_code,rnpc_percent
limit  6
"""
############################
# er_re_tax_reforms        #
############################
retf_sqlm = """
select sum(REFORM_VALUE) from
(select retf_id,retf_code,
CASE
WHEN rtrk_id = 9 THEN (
SELECT SUM (rtrt_value)
from er_re_tax_reforms_trans
WHERE PERI_ID = %d
AND retf_id = a.retf_id)
WHEN rtrk_id = 1 THEN (
SELECT SUM (rtrM_deductible_value)
FROM er_re_tax_reform_mobiles
WHERE PERI_ID = %d)
WHEN rtrk_id = 2 THEN (
SELECT SUM (rtrc_deductible_value)
FROM er_re_tax_reform_cars_trans
WHERE PERI_ID = %d)
end  REFORM_VALUE 
from er_re_tax_reforms a
WHERE retf_is_printed IS TRUE) as SU
"""
############################
# aytoelexos              #
############################
p_s_control_sqlm = """
select 
sum( retd.retd_net_value) as retd_net_value,
sum( retd.retd_net_value *rnpc_percent/100) AS perc_value
from er_re_accounts reac,
     er_re_account_tax_form_fields ratf,
     er_re_net_profit_codes rnpc,
     er_re_tran_details retd,
     er_re_tran_headers reth
where reac.peri_id = %d
 and ratf.reac_id = reac.reac_id
 and ratf.reft_id = 3
 and ratf_code = \'%s\'
 and rnpc.rnpc_id = reac.rnpc_id
 and retd.comp_id = %d
 and retd.peri_id = reac.peri_id
 and retd.reac_id = reac.reac_id
 and reth.comp_id = retd.comp_id
  and reth.peri_id = retd.peri_id
 and reth.reth_id  = retd.reth_id
AND reth_issue_date BETWEEN \'%s\' AND \'%s\'
"""
##############################
# E       #
##############################
reai_sqlm = """
SELECT reai_municipality,
reai_type_of_production,
reai_acres,
reai_mountain,
reai_watered,
reai_net_income,
reai_sum_net_income
FROM ER_RE_E3_AGRICULTURAL_INCOME
WHERE REEM_ID =%d 
limit 2
"""
##############################
#TERXNIKES ET     #
##############################
retc_sqlm = """
SELECT retc_project_location,
retc_project_type,
retc_gross_value,
retc_contractor_materials_value,
retc_employer_materials_value,
retc_net_percent,
retc_net_value
FROM er_re_e3_technical_companies
WHERE REEM_ID =%d 
limit 4
"""
##############################
#oikodomikes ET     #
##############################
reco_sqlm = """
SELECT reco_project_location,
reco_project_contract,
reco_gross_value,
reco_contractor_materials_value,
reco_net_percent,
reco_net_value
FROM er_re_e3_construction_companies
WHERE REEM_ID =%d 
limit 4
"""
##############################
#E3 CARS                    #
##############################
reec_sqlm = """
SELECT reec_taxi_base,
reec_taxi_number,
reeci_taxi_owner_percent,
reec_public_number,
reec_public_gross_load,
reec_fuel_type
FROM er_re_e3_cars
WHERE REEM_ID =%d 
limit 9
"""
####################
def MAKE_123(SCODE,NVALUE):
    if NVALUE==1:
        globals()['STR_P' + str(SCODE)+str('a')] = 'X'
    elif NVALUE==2:
        globals()['STR_P' + str(SCODE)+str('b')] = 'X'
    elif NVALUE==3:
        globals()['STR_P' + str(SCODE)+str('c')] = 'X'
    elif NVALUE==4:
        globals()['STR_P' + str(SCODE)+str('d')] = 'X'
def F_RD_REV_EXP_WT(RATF_CODE,S_RATF_CODE):
    RD_REV_EXP = sqlm(p_rev_exp_sqlm%(I_peri_id,D_date_from.strftime("%Y-%m-%d"),D_date_to.strftime("%Y-%m-%d"),RATF_CODE))
    if RD_REV_EXP.len() != 0:
        globals()['BD_P' + str(RATF_CODE)] = NVLZ(RD_REV_EXP[1].RETD_NET_VALUE)
        ####globals()['BD_P'+str(S_RATF_CODE)] += NVLZ(RD_REV_EXP[1].RETD_NET_VALUE)
        accum(globals(),'BD_P'+str(S_RATF_CODE),NVLZ(RD_REV_EXP[1].RETD_NET_VALUE))
def F_RD_REV_EXP(RATF_CODE):
    RD_REV_EXP = sqlm(p_rev_exp_sqlm%(I_peri_id,D_date_from.strftime("%Y-%m-%d"),D_date_to.strftime("%Y-%m-%d"),RATF_CODE))
    if RD_REV_EXP.len() != 0:
        globals()['BD_P' + str(RATF_CODE)] = NVLZ(RD_REV_EXP[1].RETD_NET_VALUE)
def F_RD_REV_EXP_LV(RATF_CODE,SUM_RATF_CODE):
    RD_REV_EXP = sqlm(p_rev_exp_sqlm%(I_peri_id,D_date_from.strftime("%Y-%m-%d"),D_date_to.strftime("%Y-%m-%d"),RATF_CODE))
    if RD_REV_EXP.len() != 0:
        globals()['LV_P' + str(RATF_CODE)] = NVLZ(RD_REV_EXP[1].RETD_NET_VALUE)
        accum(globals(),'LV_P' + SUM_RATF_CODE, NVLZ(RD_REV_EXP[1].RETD_NET_VALUE))
def F_RD_S_CONTROL(RATF_CODE,SUM_RATF_CODE):
    RD_S_CONTROL = sqlm(p_s_control_sqlm%(I_peri_id,RATF_CODE,I_comp_id,D_date_from.strftime("%Y-%m-%d"),D_date_to.strftime("%Y-%m-%d")))
    if RD_S_CONTROL.len() != 0:
        globals()['SC_P' + str(RATF_CODE)] = NVLZ(RD_S_CONTROL[1].PERC_VALUE)
        accum(globals(),'SC_P' + SUM_RATF_CODE, NVLZ(RD_S_CONTROL[1].RETD_NET_VALUE))
####################
######################
########################auto_sqlm 
## stoixeia etaireias ##
########################
RD_COMP = sqls(comp_sqls%(I_comp_id))
RD_REEM = sqlm(reem_sqlm%(I_peri_id))
STR_P002 = D_date_from.strftime("%d/%m/%Y")
STR_P003 = D_date_to.strftime("%d/%m/%Y")
STR_P006 = RD_COMP.COMP_FILE_NUMBER
if (I_modifiable==1):
    STR_P008a = 'X'
else:
    STR_P008a = ' '
if (B_reserved):
    STR_P008b = 'X'
else:
    STR_P008b = ' '
STR_P005a = RD_COMP.TAOF_DESCRIPTION
STR_P005b = RD_COMP.TAOF_CODE
if RD_REEM.len() != 0:
    B1_DUMMY=RD_REEM[1].REEM_IS_PAR_7
    if B1_DUMMY is True:
        STR_P593      = 'X'
    else:
        STR_P593      = ' '
    B1_DUMMY      = RD_REEM[1].REEM_IS_OBSERVE
    if B1_DUMMY is True:
        STR_P594      = 'X'
    else:
        STR_P594      = ' '
    RD_TAOF = sqlm(taof_sqlm%(RD_REEM[1].TAOF_ID))
    if RD_TAOF.len() != 0:
        STR_P007a = RD_TAOF[1].TAOF_DESCRIPTION
        STR_P007b = RD_TAOF[1].TAOF_CODE
    MAKE_123('726',RD_REEM[1].REEO_ID)
    I_P730 =RD_REEM[1].REEM_CLOSED_YEAR
    RD_COOA = sqlm(cooa_sqlm%(RD_REEM[1].COOA_ID))
    if RD_COOA.len() != 0:
        STR_P761b = RD_COOA[1].COOA_DESCRIPTION
        STR_P761 = RD_COOA[1].COOA_CODE
if RD_COMP.BOCT_ID==2:    ##### EIDOS BIBLION
    STR_P019a='X'
elif RD_COMP.BOCT_ID == 3:
    STR_P019b      ='X'
STR_P018      = RD_COMP.COMP_TIN #### afm
STR_P705      = RD_COMP.COOA_CODE   ### kad
STR_P018a      = RD_COMP.COMP_DESCRIPTION
STR_P018c     = RD_COMP.COMP_FIRST_NAME
STR_P018d     = RD_COMP.COMP_FATHER_NAME
STR_P018e      = RD_COMP.COMP_DESCRIPTION
if RD_REEM.len() != 0:
##############################
#### stoixeia syzhgoy    #####
##############################    
    STR_P041 = RD_REEM[1].REEM_HUSBAND_TIN
    STR_P041a = RD_REEM[1].REEM_HUSBAND_LAST_NAME
    STR_P041b = RD_REEM[1].REEM_HUSBAND_FIRST_NAME
    STR_P041c = RD_REEM[1].REEM_HUSBAND_FATHER_NAME
#################
### pinakas B ###
#################
    RD_REEI = sqlm(reei_sqlm%(RD_REEM[1].REEM_ID))
    for i in range(1,RD_REEI.len()+1):
        ######u.println("************* i = %d" % i);
        for j in range(1,4):
            varname = 'STR_PB' + str(i)+"_"+str(j)
            value = AnyToString(RD_REEI[i][j])
            globals()[varname]=value
##################
### pinakas G ###
#################
if RD_REEM.len() != 0:
    I_P061 =  RD_REEM[1].REEM_SUBSTORES
    I_P064 =  RD_REEM[1].REEM_WAREHOUSE
    I_P067 =  RD_REEM[1].REEM_SHOW
    I_P070 =  RD_REEM[1].REEM_WORKSITE
    I_P073 =  RD_REEM[1].REEM_OTHER_SITES
    B1_DUMMY = RD_REEM[1].REEM_HAS_INTERNET_SALES
    if B1_DUMMY is True:
        STR_P076      = 'X'
    else:
        STR_P076_n   = 'X'
    I_P062 =  RD_REEM[1].REEM_TAX_WAREHOUSE
    I_P065 =  RD_REEM[1].REEM_PERMANENT_STAFF
    I_P068 =  RD_REEM[1].REEM_SEASONAL_STAFF
    I_P071 =  RD_REEM[1].REEM_UNAUDITED_YEARS
    I_P074 =  RD_REEM[1].REEM_RELATED_COMPANIES
    B1_DUMMY = RD_REEM[1].REEM_HAS_RENDERING_SERVICE
    if B1_DUMMY is True:
        STR_P077      = 'X'
    else:
        STR_P077_n      = 'X'
    MAKE_123('063',RD_REEM[1].REEM_WRH_BOOK_RECK_ID)
    MAKE_123('066',RD_REEM[1].REEM_MPS_RECK_ID)
    MAKE_123('069',RD_REEM[1].REEM_COST_ACCOUNT_RECK_ID)
    MAKE_123('072',RD_REEM[1].REEM_ELECTRONIC_RECK_ID)
    MAKE_123('075',RD_REEM[1].REEM_INVENTORY_RECK_ID)
    MAKE_123('078',RD_REEM[1].REEM_INTERNATIONAL_RECK_ID)
####################
## pinakas D       ##
#####################
if NVLZ(I_rerp_id) != 0:
    RD_RERP = sqls(rerp_sqls %(I_comp_id,I_rerp_id))
    MAKE_123('736',RD_RERP.RERK_ID)
    STR_P736_1 = RD_RERP.RERP_LAST_NAME
    STR_P736_2 = RD_RERP.RERP_LAST_NAME2   
    STR_P736_3 = RD_RERP.RERP_FIRST_NAME
    STR_P736_4 = RD_RERP.RERP_FATHER_NAME
    STR_P741 = RD_RERP.RERP_TIN
    STR_P741a = RD_RERP.TAOF_CODE
    STR_P741b = RD_RERP.IDTY_CODE
    STR_P741c = RD_RERP.RERP_IDENTITY_NUMBER
    ####u.println("************* SRESK_ID = %d" % RD_RERP.RESK_ID)
    ####u.println("************* SRESK_ID = %d" % 1234)
    MAKE_123('741c',RD_RERP.GEND_ID)
    STR_P741d = RD_RERP.RERP_STREET+" "+RD_RERP.RERP_NUMBER
    STR_P741e = RD_RERP.RERP_CITY
    STR_P741f = RD_RERP.RERP_ZIP_CODE
if RD_REEM.len() != 0:
    MAKE_123('750',RD_REEM[1].REDY_ID)
#################
### pinakas E ###
#################
    BD_P681= RD_REEM[1].REEM_SUBSIDY_VALUE
    BD_P904= RD_REEM[1].REEM_GRANT_VALUE
    STR_P671a= RD_REEM[1].REEM_P671A
    STR_P671b= RD_REEM[1].REEM_P671B
    STR_P671c= RD_REEM[1].REEM_P671C
    STR_P671d= RD_REEM[1].REEM_P671D
    STR_P671= RD_REEM[1].REEM_P671
    BD_P672= RD_REEM[1].REEM_P672
    STR_P673a= RD_REEM[1].REEM_P673A
    STR_P673b= RD_REEM[1].REEM_P673B
    STR_P673c= RD_REEM[1].REEM_P673C
    STR_P673d= RD_REEM[1].REEM_P673D
    STR_P673= RD_REEM[1].REEM_P673
    BD_P674= RD_REEM[1].REEM_P674
    STR_P675a= RD_REEM[1].REEM_P675A
    STR_P675b= RD_REEM[1].REEM_P675B
    STR_P675c= RD_REEM[1].REEM_P675C
    STR_P675d= RD_REEM[1].REEM_P675D
    STR_P675= RD_REEM[1].REEM_P675
    BD_P676= RD_REEM[1].REEM_P676
    STR_P677a= RD_REEM[1].REEM_P677A
    STR_P677b= RD_REEM[1].REEM_P677B
    STR_P677c= RD_REEM[1].REEM_P677C
    STR_P677d= RD_REEM[1].REEM_P677D
    STR_P677= RD_REEM[1].REEM_P677
    BD_P678= RD_REEM[1].REEM_P678
    STR_P679a= RD_REEM[1].REEM_P679A
    STR_P679b= RD_REEM[1].REEM_P679B
    STR_P679c= RD_REEM[1].REEM_P679C
    STR_P679d= RD_REEM[1].REEM_P679D
    STR_P679= RD_REEM[1].REEM_P679
    BD_P680= RD_REEM[1].REEM_P680
    STR_P906a= RD_REEM[1].REEM_P906A
    STR_P906b= RD_REEM[1].REEM_P906B
    STR_P906c= RD_REEM[1].REEM_P906C
    STR_P906d= RD_REEM[1].REEM_P906D
    STR_P906= RD_REEM[1].REEM_P906
##############################
### pinakas st aagores    ###
##############################	
F_RD_REV_EXP_WT('231','251')
F_RD_REV_EXP_WT('235','251')
F_RD_REV_EXP_WT('239','251')
F_RD_REV_EXP_WT('243','251')
F_RD_REV_EXP_WT('247','251')
F_RD_REV_EXP('811')
F_RD_REV_EXP_WT('232','252')
F_RD_REV_EXP_WT('236','252')
F_RD_REV_EXP_WT('240','252')
F_RD_REV_EXP_WT('244','252')
F_RD_REV_EXP_WT('248','252')
F_RD_REV_EXP('812')
##############################
### pinakas st b apografes ###
##############################
if RD_REEM.len() != 0:
    BD_P256= RD_REEM[1].REEM_GOODS_START_VALUE
    BD_P257= RD_REEM[1].REEM_GOODS_END_VALUE
    BD_P259= RD_REEM[1].REEM_PRODUCTS_START_VALUE
    BD_P260= RD_REEM[1].REEM_PRODUCTS_END_VALUE
    BD_P261= RD_REEM[1].REEM_MATERIALS_START_VALUE
    BD_P262= RD_REEM[1].REEM_MATERIALS_END_VALUE
    BD_P264= RD_REEM[1].REEM_PACKAGING_START_VALUE
    BD_P265= RD_REEM[1].REEM_PACKAGING_END_VALUE
    BD_P267= RD_REEM[1].REEM_INCOMPLETE_START_VALUE
    BD_P268= RD_REEM[1].REEM_INCOMPLETE_END_VALUE
    BD_P270= RD_REEM[1].REEM_RESIDUE_START_VALUE
    BD_P271= RD_REEM[1].REEM_RESIDUE_END_VALUE
    BD_P520 =NVLZ(BD_P256)+NVLZ(BD_P259)+NVLZ(BD_P261)+NVLZ(BD_P264)+NVLZ(BD_P267)+NVLZ(BD_P270)
    BD_P521 =NVLZ(BD_P257)+NVLZ(BD_P260)+NVLZ(BD_P262)+NVLZ(BD_P265)+NVLZ(BD_P268)+NVLZ(BD_P271)
#########################################
### pinakas st  G AKATHARISTA EMPORIAS###
#########################################
F_RD_REV_EXP_WT('263','540')
F_RD_REV_EXP_WT('266','540')
F_RD_REV_EXP_WT('269','540')
F_RD_REV_EXP_WT('272','540')
F_RD_REV_EXP_WT('273','540')
#########################################
### pinakas st  E AKATHARISTA PAROXHS ###
#########################################
F_RD_REV_EXP_WT('279','547')
F_RD_REV_EXP_WT('276','547')
F_RD_REV_EXP_WT('519','547')
F_RD_REV_EXP_WT('282','547')
F_RD_REV_EXP_WT('273','547')
#########################################
### pinakas st  z AKATHARISTA ELEYTHER ###
#########################################
F_RD_REV_EXP_WT('274','283')
F_RD_REV_EXP_WT('277','283')
F_RD_REV_EXP_WT('280','283')
F_RD_REV_EXP_WT('275','283')
F_RD_REV_EXP_WT('278','283')
#########################################
### pinakas st  D DAPANES            ###
#########################################
F_RD_REV_EXP_LV('522','sum522')
F_RD_REV_EXP_LV('523','sum522')
F_RD_REV_EXP_LV('524','sum522')
F_RD_REV_EXP_LV('525','sum525')
F_RD_REV_EXP_LV('526','sum525')
F_RD_REV_EXP_LV('527','sum525')
F_RD_REV_EXP_LV('528','sum528')
F_RD_REV_EXP_LV('529','sum528')
F_RD_REV_EXP_LV('530','sum528')
F_RD_REV_EXP_LV('531','sum531')
F_RD_REV_EXP_LV('532','sum531')
F_RD_REV_EXP_LV('533','sum531')
F_RD_REV_EXP_LV('534','sum534')
F_RD_REV_EXP_LV('535','sum534')
F_RD_REV_EXP_LV('536','sum534')
F_RD_REV_EXP_LV('537','sum537')
F_RD_REV_EXP_LV('538','sum537')
F_RD_REV_EXP_LV('539','sum537')
F_RD_REV_EXP_LV('541','sum541')
F_RD_REV_EXP_LV('542','sum541')
F_RD_REV_EXP_LV('543','sum541')
##########
#### pososta epi ton poliseon
######
if RD_REEM.len() != 0:
    PER_EMP = NVLZ(BD_P540)*100/(NVLZ(BD_P540)+NVLZ(BD_P547)+NVLZ(BD_P283))
    PER_PAR = NVLZ(BD_P547)*100/(NVLZ(BD_P540)+NVLZ(BD_P547)+NVLZ(BD_P283))
    PER_ELE = 100-(PER_EMP+PER_PAR) ######   NVLZ(BD_P283)*100/(NVLZ(BD_P540)+NVLZ(BD_P547)+NVLZ(BD_P283))
    if RD_REEM[1].REEM_P522_HAS_SHARING is True:
        BD_P522 = round(NVLZ(LV_Psum522)*PER_EMP/100,2)
        BD_P523 = round(NVLZ(LV_Psum522)*PER_PAR/100,2)
        BD_P524 = round(NVLZ(LV_Psum522)*PER_ELE/100,2)
    else:
        BD_P522 =LV_P522
        BD_P523 =LV_P523
        BD_P524 =LV_P524
    if RD_REEM[1].REEM_P525_HAS_SHARING is True:
        BD_P525 = round(NVLZ(LV_Psum525)*PER_EMP/100,2)
        BD_P526 = round(NVLZ(LV_Psum525)*PER_PAR/100,2)
        BD_P527 = round(NVLZ(LV_Psum525)*PER_ELE/100,2)
    else:
        BD_P525 =LV_P525
        BD_P526 =LV_P526
        BD_P527 =LV_P527
    if RD_REEM[1].REEM_P528_HAS_SHARING is True:
        BD_P528 = round(NVLZ(LV_Psum528)*PER_EMP/100,2)
        BD_P529 = round(NVLZ(LV_Psum528)*PER_PAR/100,2)
        BD_P530 = round(NVLZ(LV_Psum528)*PER_ELE/100,2)
    else:
        BD_P528 =LV_P528
        BD_P529 =LV_P529
        BD_P530 =LV_P530
    if RD_REEM[1].REEM_P531_HAS_SHARING is True:
        BD_P531 = round(NVLZ(LV_Psum531)*PER_EMP/100,2)
        BD_P532 = round(NVLZ(LV_Psum531)*PER_PAR/100,2)
        BD_P533 = round(NVLZ(LV_Psum531)*PER_ELE/100,2)
    else:
        BD_P531 =LV_P531
        BD_P532 =LV_P532
        BD_P533 =LV_P533
    if RD_REEM[1].REEM_P534_HAS_SHARING is True:
        BD_P534 = round(NVLZ(LV_Psum534)*PER_EMP/100,2)
        BD_P535 = round(NVLZ(LV_Psum534)*PER_PAR/100,2)
        BD_P536 = round(NVLZ(LV_Psum534)*PER_ELE/100,2)
    else:
        BD_P534 =LV_P534
        BD_P535 =LV_P535
        BD_P536 =LV_P536
    if RD_REEM[1].REEM_P537_HAS_SHARING is True:
        BD_P537 = round(NVLZ(LV_Psum537)*PER_EMP/100,2)
        BD_P538 = round(NVLZ(LV_Psum537)*PER_PAR/100,2)
        BD_P539 = round(NVLZ(LV_Psum537)*PER_ELE/100,2)
    else:
        BD_P537 =LV_P537
        BD_P538 =LV_P538
        BD_P539 =LV_P539
    if RD_REEM[1].REEM_P541_HAS_SHARING is True:
        BD_P541 = round(NVLZ(LV_Psum541)*PER_EMP/100,2)
        BD_P542 = round(NVLZ(LV_Psum541)*PER_PAR/100,2)
        BD_P543 = round(NVLZ(LV_Psum541)*PER_ELE/100,2)
    else:
        BD_P541 =LV_P541
        BD_P542 =LV_P542
        BD_P543 =LV_P543
else:
    BD_P522 =LV_P522
    BD_P523 =LV_P523
    BD_P524 =LV_P524
    BD_P525 =LV_P525
    BD_P526 =LV_P526
    BD_P527 =LV_P527
    BD_P528 =LV_P528
    BD_P529 =LV_P529
    BD_P530 =LV_P530
    BD_P531 =LV_P531
    BD_P532 =LV_P532
    BD_P533 =LV_P533
    BD_P534 =LV_P534
    BD_P535 =LV_P535
    BD_P536 =LV_P536
    BD_P537 =LV_P537
    BD_P538 =LV_P538
    BD_P539 =LV_P539
    BD_P541 =LV_P541
    BD_P542 =LV_P542
    BD_P543 =LV_P543
BD_P544=NVLZ(BD_P522)+NVLZ(BD_P525)+NVLZ(BD_P528)+NVLZ(BD_P531)+NVLZ(BD_P534)+NVLZ(BD_P537)+NVLZ(BD_P541)
BD_P545=NVLZ(BD_P523)+NVLZ(BD_P526)+NVLZ(BD_P529)+NVLZ(BD_P532)+NVLZ(BD_P535)+NVLZ(BD_P538)+NVLZ(BD_P542)
BD_P546=NVLZ(BD_P524)+NVLZ(BD_P527)+NVLZ(BD_P530)+NVLZ(BD_P533)+NVLZ(BD_P536)+NVLZ(BD_P539)+NVLZ(BD_P543)
#########################################
### pinakas st  st        mskk       ###
#########################################
RD_MSKK = sqlm(p_mskk_sqlm %(I_peri_id,D_date_from.strftime("%Y-%m-%d"),D_date_to.strftime("%Y-%m-%d")))
BD_P344 = 0
if RD_MSKK.len() != 0:
    A=302
    B=304
    C=359
    for i in range(1,RD_MSKK.len()+1):
        varname_a = 'STR_P' + str(A)
        value_a = AnyToString(RD_MSKK[i][1])
        globals()[varname_a]=value_a
        varname_b = 'BD_P' + str(B)
        value_b = RD_MSKK[i][3]
        globals()[varname_b]=value_b
        varname_c = 'BD_P' + str(C)
        value_c = RD_MSKK[i][2]
        globals()[varname_c]=value_c
        A=A+6
        B=B+6
        C=C+1
        BD_P344 = BD_P344+value_b
#########################################
### pinakas st  h       pros log kerd ###
#########################################
BD_P548=BD_P540
BD_P549=BD_P547
BD_P550=BD_P283
BD_P551=BD_P548+BD_P549+BD_P550
BD_P552=BD_P251+BD_P252+BD_P520-BD_P521
BD_P555=BD_P552
BD_P556=BD_P544
BD_P557=BD_P545
BD_P558=BD_P546
BD_P559=BD_P556+BD_P557+BD_P558
BD_P560=BD_P548-BD_P552-BD_P556
BD_P561=BD_P549-BD_P557 ### -BD_P553
BD_P562=BD_P550-BD_P558   ###-BD_P554
BD_P563=BD_P560+BD_P561+BD_P562
RD_RETF_PARAM=retf_sqlm%(I_peri_id,I_peri_id,I_peri_id)
RD_RETF = sqlm(RD_RETF_PARAM)
if RD_RETF.len() != 0:
    RETF_VALUE =RD_RETF[1][1]
else:
    RETF_VALUE =0
BD_P564 = round(NVLZ(RETF_VALUE)*PER_EMP/100,2)
BD_P565 = round(NVLZ(RETF_VALUE)*PER_PAR/100,2)
BD_P566 = round(NVLZ(RETF_VALUE)*PER_ELE/100,2)
BD_P567 = BD_P564 + BD_P565 + BD_P566
BD_P568 = BD_P560+BD_P564
BD_P569 = BD_P561+BD_P565
BD_P570 = BD_P562+BD_P566
BD_P571 = BD_P568+BD_P569+BD_P570
########################################
### pinakas z                        ###
#########################################
if RD_REEM.len() != 0:
    BD_P840 =  RD_REEM[1].REEM_P840
    BD_P592 =  RD_REEM[1].REEM_P592
    BD_P336 =  RD_REEM[1].REEM_P336
    BD_P318 =  RD_REEM[1].REEM_P318
    BD_P312 =  RD_REEM[1].REEM_P312
    BD_P313 =  RD_REEM[1].REEM_P313
    BD_P382 =  RD_REEM[1].REEM_P382
    B1_DUMMY = RD_REEM[1].REEM_P383
    if B1_DUMMY is True:
        STR_P383      = 'X'
    B1_DUMMY = RD_REEM[1].REEM_P384
    if B1_DUMMY is True:
        STR_P384      = 'X'
#### to BD_P346 YPOLOGIZETAI META TO BD_P145
##
########################################
### pinakas i                        ###
#########################################
###
### PROSDIORISMOS SYNTELESTH ANAGOGHW
###
F_RD_S_CONTROL('263','SUM_EMP')
F_RD_S_CONTROL('266','SUM_EMP')
F_RD_S_CONTROL('269','SUM_EMP')
F_RD_S_CONTROL('272','SUM_EMP')
F_RD_S_CONTROL('273','SUM_EMP')
if SC_PSUM_EMP != 0:
    MSKK_EMP =((SC_P263+SC_P266+SC_P269+SC_P272+SC_P273)*100)/SC_PSUM_EMP
else:
    MSKK_EMP =0
BD_P101=round(100/(100-MSKK_EMP),5)
###
F_RD_S_CONTROL('279','SUM_PY')
F_RD_S_CONTROL('276','SUM_PY')
F_RD_S_CONTROL('519','SUM_PY')
F_RD_S_CONTROL('282','SUM_PY')
if SC_PSUM_PY !=0 :
    MSKK_PY =((SC_P279+SC_P276+SC_P519+SC_P282)*100)/SC_PSUM_PY
else:
    MSKK_PY =0
BD_P104=round(100/(100-MSKK_PY),5)
###
F_RD_S_CONTROL('274','SUM_EE')
F_RD_S_CONTROL('277','SUM_EE')
F_RD_S_CONTROL('280','SUM_EE')
F_RD_S_CONTROL('275','SUM_EE')
F_RD_S_CONTROL('278','SUM_EE')
if SC_PSUM_EE != 0 :
    MSKK_EE =((SC_P274+SC_P277+SC_P280+SC_P275+SC_P278)*100)/SC_PSUM_EE
else:
    MSKK_EE =0
BD_P114=round(100/(100-MSKK_EE),5)
##
BD_P121=BD_P552
BD_P122=BD_P544
BD_P102=BD_P545
BD_P112=BD_P546
BD_P100=BD_P121+BD_P122
###
BD_P125=round((BD_P100*BD_P101),2)
BD_P105=round((BD_P102*BD_P104),2)
BD_P115=round((BD_P112*BD_P114),2)
BD_P103 = BD_P125+BD_P105+BD_P115
BD_P126=BD_P540
BD_P106=BD_P547
BD_P116=BD_P283
BD_P111=BD_P126+BD_P106+BD_P116
if NVLZ(BD_P125) > NVLZ(BD_P126) :
    BD_P127=BD_P125
else:
    BD_P127=BD_P126
if BD_P105 > BD_P106 :
    BD_P132=BD_P105
else:
    BD_P132=BD_P106
if BD_P115 > BD_P116 :
    BD_P137=BD_P115
else:
    BD_P137=BD_P116
BD_P142=BD_P127+BD_P132+BD_P137
BD_P128 = round(MSKK_EMP,2)
BD_P133 = round(MSKK_PY,2)
BD_P138 = round(MSKK_EE,2)
BD_P129 = round((BD_P127*BD_P128/100),2)
BD_P134 = round((BD_P132*BD_P133/100),2)
BD_P139 = round((BD_P137*BD_P138/100),2)
BD_P143 = BD_P129+BD_P134+BD_P139
BD_P130 = BD_P568
BD_P135 = BD_P569
BD_P140 = BD_P570
for i in range(50):
    u.println("******************************")
u.printf("BD_P130=%.20f\nBD_P135=%.20f\nBD_P140=%.20f", BD_P130, BD_P135, BD_P140);
BD_P144=BD_P130+BD_P135+BD_P140
u.printf("BD_P144=%.20f", BD_P144);
#
if BD_P129 > BD_P130 :
    BD_P131 = BD_P129
else:
    BD_P131 = BD_P130
if BD_P134 > BD_P135 :
    BD_P136=BD_P134
else:
    BD_P136=BD_P135
if BD_P139 > BD_P140 :
    BD_P141=BD_P139
else:
    BD_P141=BD_P140
BD_P145=BD_P131+BD_P136+BD_P141
if BD_P145 > BD_P571 :
    LT = BD_P145
else:
    LT = BD_P571
BD_P346 = NVLZ(LT) + NVLZ(BD_P840)-NVLZ(BD_P592)-NVLZ(BD_P336)-NVLZ(BD_P318)-NVLZ(BD_P312)-NVLZ(BD_P313)
########################################
### pinakas ia                        ###
#########################################
if RD_REEM.len() != 0:
    STR_P631A = RD_REEM[1].REEM_IA_A
    BD_P631B = RD_REEM[1].REEM_IA_B
    STR_P631C = RD_REEM[1].REEM_IA_C
    BD_P631D = RD_REEM[1].REEM_IA_D
    BD_P631E= RD_REEM[1].REEM_IA_E
    BD_P631F= RD_REEM[1].REEM_IA_F
    BD_P631 = BD_P631D
    BD_P632 = BD_P631F
#################
### pinakas IB ###
#################
    BD_P635 =0.0
    RD_REAI = sqlm(reai_sqlm%(RD_REEM[1].REEM_ID))
    for i in range(1,RD_REAI.len()+1):
        for j in range(1,8):
            if j in (3,6,7):
                varname = 'BD_PIB' + str(i)+"_"+str(j)
                value = RD_REAI[i][j]
                BD_P635 =BD_P635 +value
            else:
                varname = 'STR_PIB' + str(i)+"_"+str(j)
                value = AnyToString(RD_REAI[i][j])
            #####value = unicode(RD_REEI[i][j], 'iso8859-7')
            globals()[varname]=value
    BD_P636 =RD_REEM[1].REEM_P636
    BD_P637 =RD_REEM[1].REEM_P637
    BD_P638 =RD_REEM[1].REEM_P638
    BD_P639 =BD_P636+BD_P638
    BD_P642 =RD_REEM[1].REEM_P642
    BD_P367 =RD_REEM[1].REEM_P367
    BD_P369 =RD_REEM[1].REEM_P369
    BD_P371 =RD_REEM[1].REEM_P371
    BD_P368 =RD_REEM[1].REEM_P368
    BD_P370 =RD_REEM[1].REEM_P370
########################################
### pinakas iG   texnikes            ###
#########################################
    BD_P612 = 0.0
    BD_P616 = 0.0
    RD_RETC = sqlm(retc_sqlm  %(RD_REEM[1].REEM_ID))
    for i in range(1,RD_RETC.len()+1):
        for j in range(1,8):
            if j in (3,4,5,6,7):
                varname = 'BD_PRETC' + str(i)+"_"+str(j)
                value = RD_RETC[i][j]
                if j ==3:
                    BD_P612 = BD_P612 +value
                if j ==7:
                    BD_P616 = BD_P616 +value
            else:
                varname = 'STR_PRETC' + str(i)+"_"+str(j)
                value = AnyToString(RD_RETC[i][j])
            globals()[varname]=value
    BD_P617 =RD_REEM[1].REEM_P617
    BD_P372 =RD_REEM[1].REEM_P372
    BD_P373 =RD_REEM[1].REEM_P373
    BD_P374 =RD_REEM[1].REEM_P374
    BD_P375 =RD_REEM[1].REEM_P375
    BD_P376 =RD_REEM[1].REEM_P376
########################################
### pinakas iG   oikodom           ###
#########################################
    BD_P684 = 0.0
    BD_P687 = 0.0
    BD_P690 = 0.0
    RD_RECO = sqlm(reco_sqlm  %(RD_REEM[1].REEM_ID))
    for i in range(1,RD_RECO.len()+1):
        for j in range(1,6):
            if j in (3,4,5,6):
                varname = 'BD_PRECO' + str(i)+"_"+str(j)
                value = RD_RECO[i][j]
                if j ==3:
                    BD_P684 = BD_P684 +value
                if j ==4:
                    BD_P687 = BD_P687 +value
                if j ==6:
                    BD_P690 = BD_P690 +value
            else:
                varname = 'STR_PRECO' + str(i)+"_"+str(j)
                value = AnyToString(RD_RECO[i][j])
            globals()[varname]=value
    BD_P691 =RD_REEM[1].REEM_P691
    BD_P377 =RD_REEM[1].REEM_P377
    BD_P378 =RD_REEM[1].REEM_P378
    BD_P379 =RD_REEM[1].REEM_P379
    BD_P380 =RD_REEM[1].REEM_P380
    BD_P381 =RD_REEM[1].REEM_P381
#######################################
### pinakas iD   aytokinita         ###
#########################################
    RD_REEC = sqlm(reec_sqlm  %(RD_REEM[1].REEM_ID))
    for i in range(1,RD_REEC.len()+1):
        for j in range(1,6):
            if j ==3:
                varname = 'BD_PREEC' + str(i)+"_"+str(j)
                value = RD_REEC[i][j]
            else:
                varname = 'STR_PREEC' + str(i)+"_"+str(j)
                value = AnyToString(RD_REEC[i][j])
            globals()[varname]=value
    STR_P_ID_C_A = RD_REEM[1].REEM_ID_C_A
    I_P_ID_C_B = RD_REEM[1].REEM_ID_C_B
    I_P_ID_C_C = RD_REEM[1].REEM_ID_C_C
    I_P_ID_C_D = RD_REEM[1].REEM_ID_C_D
    I_P_ID_C_E = RD_REEM[1].REEM_ID_C_E
    STR_P_ID_C_F = RD_REEM[1].REEM_ID_C_F
    I_P_ID_C_G = RD_REEM[1].REEM_ID_C_G
    B1_DUMMY = RD_REEM[1].REEM_ID_C_H
    if B1_DUMMY is True:
        STR_P_ID_C_H      = 'X'
    B1_DUMMY = RD_REEM[1].REEM_ID_C_I
    if B1_DUMMY is True:
        STR_P_ID_C_I      = 'X'
    STR_PNOTICE=RD_REEM[1].REEM_NOTICE


sql_exec('INSERT INTO testdata(a,b) VALUES(%s,%s)'%(N2N(1)   , N2N('alpha')
sql_exec('INSERT INTO testdata(a,b) VALUES(%s,%s)'%(N2N(2)   , N2N(None))
sql_exec('INSERT INTO testdata(a,b) VALUES(%s,%s)'%(N2N(None), N2N('c')))
sql_exec('INSERT INTO testdata(a,b) VALUES(%s,%s)'%(N2N(None), N2N(None)))
sql_exec('INSERT INTO testdata(a,b) VALUES(%s,%s)'%(N2N(None), N2N(u'  ')))


##sql_exec('INSERT INTO testdata(a,b) VALUES(2d, \'b\')')

#boo



for (k,v) in globals().items():
    if (type(v)==float):
       u.printf("******************** %s = %.20f", k, v)
    params.put(k, v)